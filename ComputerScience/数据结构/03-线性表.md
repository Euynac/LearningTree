# 线性表

## 定义

**逻辑结构**。相同数据类型，**有限**序列，是具有n个数据元素的有限序列。在线性表中，除最后一个元素（或第一个）元素外，每个元素只有一个后继（或前驱）元素。

## 顺序存储结构方式实现（顺序表）

使用顺序存储结构方式实现的线性表又叫顺序表

特点是逻辑顺序与其物理顺序相同。

优点：随机访问（即通过首地址和元素序号可在`O(1)`内找到指定元素）；存储密度高，结点只存储数据元素

缺点：逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动的大量元素

### 插入元素

线性表长度是指的当前元素的总个数长度，而不是定义的线性表最大空间的长度。因此插入操作所指定的第`i`个位置，其含义是元素与元素之间的位置，因此`i`的取值范围是`1≤i≤L.length`(线性表长度)`+1`。`i`取`L.length+1`的含义是从表尾插入。比如线性表长度为1，只有一个元素，那么元素前后有两个位置，第一个位置和第二个位置。

## 链式存储结构方式实现（链表）

### 单链表

一个结点内有数据域`data`和后继结点指针域`next`，这种结构又叫单链表。对于每个链表结点，除存放元素自身信息之外，还需要存放一个指向其后继的指针。

缺点：查找某个特定的结点时，需要从表头开始遍历，依次查找。

#### 增加头结点的目的

方便运算的实现。
1. 有头节点后，插入和删除数据元素的算法统一了，不再需要判断是否在第一个元素之前插入或删除第一个元素 
2. 不论链表是否为空，其头指针是指向头结点的非空指针,因此空表和非空表的处理也就统一了。

### 双链表

单链表要访问某个结点的前驱结点时，只能从头开始遍历。双链表即有两个指针域（增加前驱结点指针域`prior`）

### 循环链表

即单链表的尾结点不是指向`NULL`而是指向头结点（即等于头指针）。循环链表若常在链表尾部进行操作，则可只增设尾指针`r`而可不用头指针（因为头指针即`r->next`）

循环双链表即双链表的尾结点的后继指针指向头节点，头节点的前驱指针指向尾结点。频繁删除尾结点的时候因为要访问表尾元素的前驱结点，因此使用双循环链表更好。

循环链表从头/尾插入的时候，要注意保持最后一个结点指向头结点，若此时只设头指针（即没有头结点也没有尾指针），则在链表头插入的时间复杂度为`O(n)`（因为要找尾结点）

### 静态链表

静态链表借助数组来描述线性表的链式存储结构，结点也有数据域和指针域。但这里的指针不同，是结点的相对地址（数组下标），又称游标。以`next==-1`作为其结束的标识。在不支持指针的语言中是一种巧妙实现链表的方法。（实际上没有单链表使用起来方便）

![静态链表示意图](../attachments/b4a4c05d332f0937f3e0d0e974b7369e.png)

和顺序表一样需要预先分配一块较大的连续的内存空间

## 栈（Stack）

是只允许在一端进行插入和删除操作的操作受限的线性表，这一端称为栈顶（`Top`）。栈底（`Bottom`）即栈的另一端，无法进行操作。特点是后进先出`LIFO`（`Last In First Out`）

### 卡特兰数

[卡特兰数相关资料1](http://blog.sina.com.cn/s/blog_6917f47301010cno.html)

[卡特兰数相关资料2](https://blog.csdn.net/qq_30115697/article/details/88906534)

![卡特兰数公式](../attachments/33fe2a3b4822b1eecef6d0c1c9ce1414.png)

分子可以这样理解：一共需要`n`次一种操作，`n`次另一种操作，加起来一共`2n`种操作，然后假设没有限制（操作间没有执行顺序限制），算另一种操作的可能排列情况。

可以应用于 `n`个不相同的元素依次进栈，有多少种不同的出栈序列。

分母可以这样理解，出栈这个操作次数不能大于进栈操作，所以是有限制的，需要除（暂时只能死记`n+1`）

比如已知先序序列，求有多少种可能的中序序列（即有多少种不同的树（因为先序序列和中序序列可以唯一的确定一棵树））（先序序列与中序序列的关系相当于以先序序列为入栈次序、以中序序列为出栈次序）

### 上溢与下溢

如堆栈已满，但还想再存入信息，这种情况称为堆栈上溢；另一种情况是，如堆栈已空，但还想再取出信息，这种情况称为堆栈下溢。

### 顺序栈（顺序存储结构实现）

```c
typedef struct {
    Elemtype data[MaxSize]; //定义栈中元素最大个数
    int top; //栈顶"指针"，规定top=0和-1表示空栈情况实现有所不同。top=0即栈顶总是指向栈顶元素的下一个存储单元。一般教科书规定top=-1
}
```

#### 共享栈

一个数组左边为一个栈的栈底，右边为另一个栈的栈底

好处是节省存储空间，降低发生上溢的可能（因为就算是两个栈顶接触了，也没有突破空间的大小，只是会给另一个栈带来错误）

### 链栈（链式存储结构实现）

优点是便于多个栈共享存储空间和提高其效率，且没有栈上溢的情况，通常用单链表实现，且所有操作都在表头进行。（注意有无头结点的实现）

### 栈的应用

递归、进制转换、迷宫求解、括号匹配

程序使用栈来保存调用过程的信息：调用函数时，系统会为调用者构造一个由参数表和返回地址组成的活动记录，并将记录压入系统提供的栈中，若被调用函数中有局部变量，也要压入栈中。

#### 表达式求值

中缀表达式转后缀表达式，只需要一个运算符栈

从左至右扫描，遇到数字时，直接加入后缀表达式。

遇到运算符时：

1. 若为"`(`"，直接入栈。

2. 若为"`)`"，把栈内的运算符依次输出，直到遇到"`(`"，删除"`(`"。

3. 若为其他运算符，当优先级高于栈顶的运算符或栈顶运算符为"`(`"时，直接入栈。否则弹出栈顶运算符，然后继续进行判断栈顶优先级，直到成功入栈。

当扫描的中缀表达式结束后，栈中所有运算符依次出栈加入后缀表达式。

## 队列（Queue）

是只允许在一端（队尾`Rear`指针处）插入，另一端（队头`Front`指针处）删除的操作受限的线性表。特点是先进先出`FIFO`（`First In First Out`）

队头是出的一端，队尾是进的一端。参考排队，从队尾排起，队头处理。

### 顺序队列（顺序存储结构实现）

`rear`和`front`两个指针注意不同定义。

缺点是队列会出现上"溢出"实际上是一种"假溢出"，因为队列还有存放元素的空位置，只是`rear`和`front`到头了。

#### 循环队列

将顺序队列在逻辑上表现为一个环，队首指针到达`MaxSize`后，会回到头位置，可以使用除法取余运算实现。

判断循环队列队空和队满的条件都是`rear=front`，有几种区分方式：
1. 牺牲一个单元来区分队空和队满。
2. 类型中增设队列长度的数据成员。
3. 类型中增设`tag`数据成员（`bool`型），因删除导致的`front==rear`则为队空，`tag=0`；因插入导致的`front==rear`则为队满，`tag=1`。

### 链队列（链式存储结构实现）

实际上是一个同时带有队头指针和队尾指针的单链表。（通常会选用带头结点的单链表实现）

优点是不会出现存储分配不合理和"溢出"的问题。

在用单链表实现队列时，队头总设在链表的链头位置。（因为链尾删除还要找前驱结点）进行删除操作时，头尾指针可能都要修改（因为若只有一个元素，删除这个元素后，队列为空，`rear`指针要修改为`rear==front`）

### 双端队列

是允许两端都可以进行入队和出队操作的队列。

![双端队列](../attachments/3f586b029821fbea1b31b7a808146884.png)

分为前端和后端。实际上实现只需要两个指针，一个是`rear`、一个是`front`。如图所示分左右情况：初始为空时假设两者都在同一个元素上，`front`、`rear`两端都可以增加和删除元素，`front`的增加后即往右移动，删除即向左移动，`rear`增加是从当前插入元素"向左移动"（从第一个位置整体向右让出一位插入），删除则是"向右移动"（删除第一个元素后整体向左移动）。实际上用链表会更好理解。（模拟插入的时候就从中间开始，右边、左边都可以插入删除）

**输出受限的双端队列**：是指在一端允许插入和删除，但另一端只允许插入的双端队列。

**输入受限的双端队列**：是指在一端允许插入和删除，但另一端只允许删除的双端队列。

输出序列的第一个数是`n`，说明至少要进行`n`次插入才有可能第一个得到`n`。

### 应用

缓冲区、层次遍历二叉树、广度优先搜索图、操作系统中页面置换算法中的先进先出置换算法（`FIFO`）

## 数组

数组是由`n`个相同类型的数据元素构成的有限序列，是线性表的推广，只有存储元素和修改元素的操作。

### 矩阵的压缩存储

#### 稀疏矩阵

即很大的矩阵里面有很少的有效值。

适用于压缩存储稀疏矩阵的两种存储结构是三元组表和十字链表 