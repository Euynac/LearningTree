# 排序

数组排序的最好的时间复杂度为`O(nlog2n)`吗？当`n`个关键字之间是随机分布的话，任何基于比较的排序算法，至少需要`O(nlog2n)`的时间（因为判定树）

对任意`n`个关键字排序的比较次数至少为`[log2(n!)]`（向上取整）（至少是指最坏情况）

算法的稳定性是经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变，只是一种性质，并不是优劣。

一般情况下默认排序结果都是非递减有序序列。

## 插入排序

基本思想是每次将一个记录按照大小插入到已经前面已经排好序的子序列中，使得子序列仍保持有序

### 直接插入排序

```c
void InsertSort(int list[], int n) // 升序排列
{
    for (int i = 2; i <= n; i++)
    {
        if(list[i] < list[i - 1]) { //如果有序子序列最后一位都小于要插入的元素，则可以直接放入子序列，否则进行插入
            list[0] = list[i]; //第0位"哨兵"，暂存要插入的元素，且可以用作判断末尾
            int j = i - 1; //从有序子序列后往前找
            for (; list[j] > list[0]; j--) //体现了哨兵的好处
                list[j + 1] = list[j]; //给要插入的元素腾位置
            list[j + 1] = list[0]; //覆盖插入元素到插入的位置
        }
    }
}
```

是稳定的排序算法，适用于顺序存储和链式存储。时间复杂度为`O(n^2)`

### 折半插入排序

直接插入排序是边比较边移动元素，这个比较可以进行优化，即先分离比较和移动元素两个操作，先折半查找到要插入的位置然后统一移动。

仅减少了比较元素的次数，移动次数并未改变，总时间复杂度仍为`O(n^2)`

也是稳定的排序算法

### 希尔排序（缩小增量排序）

注意到如果直接插入排序待排序列是正序的时候，时间复杂度可以达到`O(n)`，如果序列基本有序，那么效率就会相对提高，所以直接插入排序更适合基本有序和数据量不大的排序表。

希尔排序基本思想是将待排序表按照一定增量序列将表分为若干个子表，然后对子表原地进行直接插入排序，然后进一步缩小增量，继续分割子表，这时候子表内的数据较原来是相对有序的

当前最优的增量序列尚未定论，一般增量先`d1 = n/2`，下一次`di+1=[di/2]`(向下取整)，最后增量缩减至1。

最坏情况下时间复杂度为`O(n^2)`，但`n`在某个范围时约为`O(n^1.3)`，涉及数学难题，难以计算准确的时间复杂度。

是不稳定的排序算法，因为分组排序的时候顺序可能已经被打乱。

## 交换排序

### 冒泡排序（Bubble Sort）

基本思想是从一端到另一端两两比较元素。

比如从前往后，大的元素放在后面，则执行完一次，最大的就会被放在最后面（即一旦开始遇到的最大的这个泡泡就会不断的冒到最后），且这个位置已经确定了。那么下一趟就会有第二大的元素位置被确定，以此类推。

是稳定的排序算法。

平均时间复杂度为`O(n^2)`

最好情况的平均复杂度为`O(n)`（当序列基本有序时）

适用于顺序存储和链式存储。

### 快速排序

基于分治法的思想，任取一个枢轴（`pivot`），作为比较的基准，将所有其他的元素比如小于这个枢轴的放左边，大于这个枢轴的放右边，那么最终确定了这个枢轴最终的位置，这一趟称为一次快速排序（或一次划分（`partition`））。且接下来可以分别对两个划分好的子序列继续进行快排，最终就确认了所有枢轴的位置。

实际上算法性能主要取决于划分操作的好坏。

考研要求的划分操作为：

[快速排序动画演示](https://www.bilibili.com/video/BV1Yt4y1i7tJ)

对于一个子序列：

初始标记`low`为最左边的一个元素，`high`为最右边的一个元素。

1. 取表中第一个元素作为枢轴（暂存为`pivot`变量）

2. `high`向左找到一个比枢轴小的元素，停下

3. `low`（第一趟实际上是直接指向枢轴（但实际上`pivot`已被暂存，这里`i`指向的可以当做空位置），所以`low`不用移动）向右找到一个比枢轴大的元素，停下

4. `low`和`high`元素交换，这就同时把一个比枢轴小的元素换到了左边，比枢轴大的元素放在了右边。

（实际上实现的时候可以直接在步骤2找到小的元素的时候直接覆盖当前`low`所在位置的元素，然后`low`会跳过这个元素继续往下找到大的，再直接覆盖`high`所在位置，因为`pivot`已被拿出来暂存，那`i`初始就是相当于空位置）

5. 继续移动`low`、`high`，进行步骤2、3、4的步骤，直到`low>=high`为止，就完成了一次划分操作。

是不稳定的算法。平均时间复杂度为`O(nlog2n)`（是所有内部排序中平均性能最优的排序算法），最坏时间复杂度为`O(n^2)`（当本来就是逆有序时），最好为`O(log2n)`。

适用于顺序存储和链式存储

## 选择排序

基本思想是打擂法选出一个最小的元素，然后放在子序列首位（即每一趟都可以确定一个元素的最终位置）。然后下一趟序列长度减一，继续处理下一个子序列。

### 简单选择排序

打擂法选出一个最小的元素，然后放在子序列首位（与子序列的首位元素交换）（即每一趟都可以确定一个元素的最终位置）。然后下一趟序列长度减一，继续处理下一个子序列。

适用于顺序存储和链式存储，不稳定（找到的最小元素放在子序列首位的时候，即与首位元素交换，如果刚好首位元素是与最小元素临近的元素相同大小，那么这次交换就打乱了它们原有的顺序），平均时间复杂度为`O(n^2)`

关键字比较次数与记录的初始排列无关（打擂法必须遍历一遍）

### 堆排序

思想是建立一个堆（大根堆（大顶堆）：对于一个子树或整个数中，根的值最大，左右孩子都比根小。小根堆（小顶堆）：根的值最小）

即根结点（假设序号为`i`）的大小都比它的左右孩子要小/大（大顶堆即`i>=2i`且`i>=2i+1`）。

堆可以看作是一个完全二叉树。

平均时间复杂度为`O(nlog2n)`

空间复杂度为`O(1)`

是不稳定的算法（因为相同大小的元素被放到堆顶然后被放在树的末尾时，可能顺序已经被打乱）。

#### 初始堆的构建

对于大顶堆，从倒数第二层元素开始，以它作为三个结点的小子树的根结点（即`i`从`[n/2]`向下取整开始，这样就肯定能拿到它的左/右孩子），从左右孩子中选择一个更大的与当前根结点大小比较，如果它的孩子更大，则与根节点交换（如果是到了更高层的调整，那么交换就还破坏了它下一层的堆性质，那么还要调整被破坏那一侧孩子的三结点子树，依次一层层自上而下调整下去），直到调整到整个树的根结点。时间复杂度为`O(n)`，因此如果只需要前几个大小之类的，就适合堆排序，只需要初始化然后取前几个即可。

#### 堆有序序列的输出（堆排序）

如大顶堆，当前堆顶就是整个堆中的最大值，那么可以直接输出（或者直接与树的最后一个结点元素交换，然后让树的总数-1即排除这个结点，意味着它的位置已经固定），然后把最后一个元素放上根节点，做一次自上而下的调整，然后就又成了一个堆，以此类推。

#### 堆元素的插入

如大顶堆，从树末尾插入一个结点，然后自底向上（是当前插入结点的双亲结点作根）对整个树进行调整。

## 归并排序

二路的意思是每次合并两组序列

![归并排序示意图](../attachments/41006bc28431d91f68012698ebe9b580.png)

合并已排序的子表时间复杂度为`O(n)`

二路归并排序平均时间复杂度为`O(nlog2n)`，空间复杂度为`O(n)`（因为用了一个辅助数组用于合并）

是稳定的（因为归并操作还是遵循原有次序的），适用于顺序存储和链式存储

## 基数排序

不基于比较的排序。它的思想是分配和收集，对单逻辑的关键字进行排序，逻辑分为最高位优先（`MSD`，`Most Significant Digit First`），和最低位优先（`LSD`，`Least Significant Digit First`），即对于一个数据，它每一位是分大小的，即每一位也是一个关键字。

高位是指一个数据的越后面是越高位（比如第一位、第二位，显然二比一大，即"高位"），比如数字就是个位数比百位数位数要高，高位优先的意思是权重高位比低位要优先，低位优先即低位权重更高。因此选择低位优先还是高位优先要看数据的特性，比如数字就必须选择低位优先才可以得到正确的排序结果。（其实原理就是把一个数据分为了几个关键字，然后按照关键字的不同权重顺序进行排序，加权排序，不过这里要区分一下，权重越高越后才排序，先把低权重的捋顺了再捋高权重的才是正确的结果，即越后排序的越决定最终顺序）

基数排序中有几个关键变量：`d`元组，即每个元素关键字位数，决定了需要进行多少趟排序。`r`是每个关键字位数的取值范围，比如数字即0~9，共有10个范围，因此`r`为10，它决定了队列的总数，队列的顺序很重要，分别对应每个关键字的取值，因此队列间的顺序也必须有序区分。

![基数排序示例](../attachments/33416ae2d9d98373a7727d4461d4434c.png)

对于排序三位数的数字，第一趟使得个位有序，第二趟使得十位上大小有序，同时个位也有序，第三趟则使得百位、十位、个位都有序。

时间复杂度为`O(d(n+r))`，空间复杂度为`O(r)`（要用到`r`个队列）是稳定的排序。

## 应用

考虑因素：

元素数目

元素大小（如果元素本身比较大，进行常有交换、移动的排序可能效率很低，不过最好办法是换用链式存储，然后使用支持链式存储的排序）

关键字结构（比如处理的关键字本身是有序或逆序，使用快排效率就很低下）

关键字分布（看分布是否适合基数排序）

稳定性

存储结构

辅助空间 