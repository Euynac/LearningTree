# 基本概念

数据结构三要素：逻辑结构、物理结构和数据运算

抽象数据类型(`Abstract Data Type`,`ADT`)描述了数据的逻辑结构和抽象运算，通常用（数据对象，数据关系，基本操作集）这样的三元组来表示，从而构成一个完整的数据结构定义。

计算机内部数据处理的基本单元是数据，数据的基本单位是数据元素，数据项是数据元素不可分割的最小单位。

## 逻辑结构

数据的逻辑结构是从面向实际问题的角度出发的，是抽象的。从它与数据的实际存储无关，是独立于存储结构的，其数据的存储方式有多种不同的选择。

有序表是逻辑结构而不是存储结构，是指关键字有序的线性表（即排好序的）。

### 如何区别逻辑结构与物理结构

当一个结构，如数组、链表、树、图，在逻辑结构中只有一种定义，而在物理结构中却有两种选择，那么这个结构就属于逻辑结构；

相反，当此结构在原有基础上加上了某种限定，使得其在物理结构中只有一种定义，那么这个结构就属于物理（存储）结构；

## 存储结构（物理结构）

物理结构，是数据结构在计算机中的表示（映像）

在存储数据时，通常不仅要存储各数据元素的值，还要存储元素之间的关系（比如索引、指针等）（数据元素的类型可以不必存储）

### 顺序存储

逻辑上相邻的元素存储在物理上相邻的存储单元中。

优点：可以随机存取（说的是随机存取这种特点的存储结构）；每个元素占用最小的存储空间

缺点：只能用一整块存储单元，会产生较多的外部碎片

比如顺序表（线性表的顺序存储实现方式）（循环队列是用顺序表表示的队列）。

也适用于图、树等逻辑结构的实现，因此并非只适合用于线性结构。

### 链式存储

逻辑上相邻但不要求物理上相邻，而是使用多一块空间存储下一个数据的地址（即指针）链接到所在物理位置。

优点：
1. 不会出现碎片现象，能够充分利用所有存储单元
2. 因为使用指针表示逻辑结构，而指针的设置是任意的，故相比于顺序存储可以更方便的表示各种逻辑结构（顺序存储只能用物理上的邻接关系来表示逻辑结构）

缺点：存储指针会额外占用存储空间；只能**顺序存取（说的是顺序存取这种特点的存储结构）**

比如单链表

链式存储设计时，结点内存储单元的地址一定连续（指的是这个链表结点内部成员，比如指针和其数据是连续的）。而各个不同结点存储空间可以不连续

### 索引存储

在存储信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。

优点：检索速度快；

缺点：附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。

### 散列（哈希）存储

根据元素的关键字直接计算出该元素的存储地址，又称哈希(`Hash`) 存储。

优点：检索、增加和删除结点的操作都很快；

缺点：若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

比如哈希表

## 算法

一个算法应该是问题求解步骤的描述。

### 时间复杂度与空间复杂度

一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为`T(n)`，时间复杂度主要分析`T(n)`的数量级。算法的空间复杂度`S(n)`定义为该算法所耗费的存储空间。记为`S(n) = O(g(n))`。其中`n`是**问题规模**

`T(n) = O(n^2)`是执行时间与`n^2`成正比

算法原地工作是指算法所需的辅助空间是常量。

`O`（量级(`order`)）表示时间/空间复杂性增长率的上界，但不是上确界。即是根据它们的同阶无穷大来比较的。比如`O(n)`与`O(2n)`，认为具有相同的时间复杂度。

算法时间复杂度为`log(n)`时，不同底数对应的时间复杂度的倍数关系为常数，不会随着底数的不同而不同，因此可以将不同底数的对数函数所代表的时间复杂度，当作是同一类复杂度处理，即抽象成一类问题。

### 计算技巧

#### 非递归型

设循环次数`t`，表达出变量和次数之间的关系

```c
int i = 1;
while(i <= n)
    i*=2;
```

最终`i = 2^t`，即`2^t < n` 解出`t`即是答案。

小心`while(sum < n) sum+=++i;` 这个是`O(n^(1/2))`，因为`sum=sum+i;`

#### 递归型

`move()`的时间复杂度为 `O(1)`

```c
void hanoi(int n,char x,char y,char z)
{
    if(n==1)
        move(x,1,z);
    else
    {
        hanoi(n-1,x,z,y);
        move(x,n,z);
        hanoi(n-1,y,x,z);
    }
}
```

设函数`hanoi`数据规模为`n`时的时间复杂度为`T(n)`（即代入`n`时），从代码中写出`T(n)`的表达式：

`T(1)=1`

`T(n)=T(n-1) + 1 + T(n-1)=2T(n-1) + 1`

则可以把`T(n)`看作`an`，`T(n-1)`看作`an-1`，则是数列的递推公式求通项公式。

`an = 2an-1 + 1`

解得`an=2^n`，即时间复杂度为`T(n)=O(2^n)` 