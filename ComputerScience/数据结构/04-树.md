# 树

树的定义是递归的，是一种递归的数据结构，是逻辑结构，同时也是一种分层结构

## 术语

### 度

树中一个结点的孩子个数称为该结点的度，树中结点最大度数称为树的度。度为`n`的树和`n`叉树不同，前者至少有一个结点有`n`个孩子，而后者最大孩子数不超过`n`。

### 深度、高度和层次

结点的层次从树根开始定义。同一层的结点称堂兄弟

结点的深度是从根节点开始自顶向下计算的

结点的高度是从叶节点开始自底向上计算的

树的高度（或深度）是树中结点最大层数（一般定义为从1开始数）

### 有序树和无序树

如果互换子节点变为一颗不同的树，则为无序树，否则是有序树

### 路径和路径长度

结点间的路径是由两个结点之间所经过的结点序列构成的，路径长度是路径所经过的边的个数。

树的路径长度是从树根到每个结点的路径长度的总和

### 森林

把一颗树的根结点去掉，变成`n`个互不相交的数，这个集合即为森林。

森林是`m`（`m≥0`）棵互不相交的树的集合

## 性质

1. 树中的结点数为所有的结点的度数（即孩子数，或看成边）加1（即加上根结点）

叶节点的度数是0，度为`n`的树的所有结点总数=叶节点数（度为0的结点）+度为1的结点总数+度为2的结点总数+…+度为`n`的结点总数

2. 度为`m`的树（即一个结点的最大孩子数为`m`）中第`i`层上至多有`m^(i-1)`个结点(`i≥1`)

每一层每个结点都是有`m`个孩子，可以推出规律。（因为从第一层根结点开始，下一层最大结点数就是上一层乘`m`）

3. 高度为`h`的`m`叉树至多有`(1-m^h)/(1-m)`个结点。（即首项为1的等比数列公式）

4. 具有`n`个结点的`m`叉树的最小高度为`⌈log_m(n(m-1)+1)⌉` （向上取整）

即通过满`m`叉树计算高度，利用性质3的公式=`n`直接推出`h`

5. 具有`n`个结点的度为`m`的树高度至多是`n-m+1`（最下一层是`m`个结点，之上都是一个结点，`n-m`即上面所有高度，再加最后一层即树的总高度）

## 树的存储结构实现

![树的存储结构](../attachments/92f86d1cc2820a18be85fa585360f71c.png)

### 双亲表示法（顺序存储）

使用一组连续的空间来存储每个结点，每个结点中增设一个伪指针(数组下标)，指向其双亲结点在数组中的位置。根结点下标为0，指针为-1。双亲结点优点是可以很快得到每个结点的双亲结点。但求结点的孩子结点要遍历整个结构。

![双亲表示法](../attachments/cd2f7c1805a368ded8bf9d9b0186bf99.png)

### 孩子表示法（链式存储）

类似双亲表示法，也是采用一组连续空间存储每个结点，但不同的是每个结点增设一个指针域，里面指向的是该结点的从左至右的所有孩子。

![孩子表示法](../attachments/ab57ca210daeeee1d929851566b1da92.png)

找孩子很容易但是找双亲要遍历每个链。

可以将双亲表示法和孩子表示法合二为一变为孩子双亲表示法。优点合并。

![孩子双亲表示法](../attachments/1f517e4c2c0da529f54ae7cd85cc7f55.png)

### 孩子兄弟表示法（又称二叉树表示法）

以二叉链表为数的结存储结构，左指针指向第一个孩子结点，右指针指向（从左至右的）兄弟结点。

![孩子兄弟表示法](../attachments/379ec504ca285f2ae7b792a04abd4b46.png)

优点是可实现树转二叉树、易于查找结点的孩子等。缺点是从当前结点找双亲结点比较麻烦，但可以增设一个`parent`指针指向父节点。

## 树和森林的遍历

### 先根遍历

即先访问结点，然后依次遍历结点的孩子。`NC1C2…Cn`

森林的先根遍历（某些地方称先序遍历）也是，从第一棵树开始使用先根遍历、然后到下一棵树。

树、森林转换为二叉树后，对应二叉树的先序遍历与它们的先根遍历序列相同。

### 后根遍历

即先依次遍历结点的孩子，最后访问结点。`C1C2…CnN`

森林后根遍历（某些地方又称中序遍历，可能是指它对应的二叉树是中序遍历）同理。

其与树、森林对应的二叉树的中序遍历序列相同。

### 层次遍历

即一层一层遍历。

## 应用

### 并查集

主要用于解决一些元素分组的问题。它管理一系列不相交的集合，一般有三种操作：

初始化（`Initial`）把每个点所在集合初始化为其自身（即变成森林）

查询（`Find`）查找元素所在的集合，即根节点。

合并（`Union`）将两个元素所在的集合合并为一个集合。通常来说，合并之前，应先判断两个元素是否属于同一集合（即不相交），这可用上面的"查找"操作实现。

通常用树的双亲表示作为并查集的存储结构。整个集合初始化形成的是森林，每个树只有一个根节点就是元素自身，伪指针域为负数。

经过一系列合并后，剩下的就是分好组的树，然后通过`Find`操作可以找到一个元素所属的组。（即双亲表示法的优点，找双亲结点很快）

### 哈夫曼编码（Huffman）

数据通信中，若对每个字符使用等长的二进制数表示，则称这种编码方式为*固定长度编码*。若允许对不同字符用不等长的二进制位表示，则称*可变长度编码*。可变长度编码是对频率高的字符用短编码，频率低的用较长的编码，起到数据压缩的效果。

其中一种就是哈夫曼编码。

没有一个编码是另一个编码的前缀，称之为*前缀编码*。如0，101，100，从第一个字符开始可以解码所有字符不会歧义。而如果是0和00，则无法唯一编译。

将数据构造成哈夫曼树，然后选择左子树、右子树相应为0或1，然后从根到指定结点的路径上的标记的序列即哈夫曼编码，且满足前缀编码的特性。

### TireTree（字典树，单词查找树）

`AC Automata` on `double array trie`, `rank-select`, `DFUDS trie`, `louds trie`, `patritia-trie`, `recursive-patricia-trie`, `AcTrie`,

`AC` 自动机本质上是一个 `Trie + FailLink`

## 自动机

计算机控制系统的控制程序具有有限状态自动机（`FA`）的特征，可以用有限状态机（`Finite Automata Machine`）理论来描述。在软件开发领域内通常被称作有限状态机（`Finite State Machine`，`FSM`），是一种应用非常广泛的软件设计模式。

### Aho-Corasick automaton（AC自动机）

多模匹配算法

`DFA`，全称 `Deterministic Finite Automaton` 即确定有穷自动机：从一个状态通过一系列的事件转换到另一个状态，即 `state -> event -> state`。

## 二叉树

每个结点至多只有两颗子树（即不存在度大于2的结点，即孩子最多有两个），且有左右之分，是有序树。

与度为2的树不同，度为2的树至少有三个结点（即至少存在一个度为2的结点），而二叉树可以为空二叉树。另外二叉树是有序的，两个结点的二叉树有两个，分左边子树和右边子树。

## 性质

1. 非空二叉树上叶子结点数 = 度为2的结点数 + 1

即`n0=n2+1` （`ni`代表度为`i`的结点数目）

因为二叉树的总度数（也即二叉树总结点数） = `n0+n1+n2 = 1*n1 + 2*n2 + 1`

2. 含有`n`个结点的二叉树，拥有`n+1`个空结点（二叉链表中称为空链栈）

从一个根节点开始想，有两个空结点，随意增加一个结点，空结点总数变成`2-1+2`，以此类推。

性质1、2都可以根据`n=n0+n1+n2`与 `n=1*n1+2*n2+1`两个公式推导出来。

3. 度为1的结点只会有0或1个，因此使用上面的公式时，可以分类讨论，然后带入0、1获得结论。

**顺序存储结构实现**

一维数组连续存储层次遍历的完全二叉树（不存在的结点用空结点表示），但浪费空间。建议从1开始存储树中的结点，这样就满足了`2i`是左孩子之类的性质。

**链式存储结构实现**

二叉链表实现，结点含：`lchild`、`data`、`rchild`，左右孩子两个指针，一个数据域。

还可以增加某些指针域，比如指向父节点，变为三叉链表。

## 满二叉树

树每层含有最多的结点，即除叶子节点外其他结点度数均为2。可以给满二叉树编号，从上至下，从左至右依次编号。一般是从根节点编号为1开始。

## 完全二叉树

满足满二叉树编号次序的树，即还未达到满二叉树状态的中途树（假设一个一个加结点，是按照满二叉树编号次序加的）

注意给定叶子节点数考虑最多结点的情况，推算出最底层的叶子结点数后，倒数第二层没有孩子的最左边的叶子结点可以增加一个左孩子，因为这样不改变叶子节点数而且达到树结点最多。

### 特征

当`i>1`时，`i`为偶数时（即是左孩子时），双亲的编号为`i/2`，奇数时（即是右孩子时），编号为`(i-1)/2`

第`i`个结点的左孩子的编号为`2i`（若存在）（如果题目没有说若左孩子存在，则描述是错的）

## 二叉排序树(Binary Search Tree, BST二叉查找树)

假设树中数据域存储的是可比较的元素，那么左子树上的所有结点的元素都小于其根节点，右子树上的都大于其根节点（递归定义）即左子树结点值≤根结点值≤右子树结点值（此时中序遍历是得到升序序列）（但考试可能会说得到降序序列，此时注意它的定义是左子树结点值≥根结点值≥右子树结点值）

### 删除结点

删除结点后会进行调整，使其重新成为二叉排序树。二叉树删除后插入同一个元素（二叉排序树插入的结点一定变成了某个叶节点，但如果是平衡二叉树，经过平衡调整后并不一定是叶结点），所得的树不一定相同。

删除结点时，如果删除的结点无左子树但有右子树，用右子树根结点填补。无右子树但有左子树用左子树根结点填补。如果左右都有子树，则用右子树的最左结点填补（书上说是中序第一个子女，其实就是右子树值最小那个填补（其实也可以拿左子树值最大的那个填补））

### 查找效率

主要取决于树的高度。最差情况是单枝树，平均查找长度是`O(n)`，所以尽量要变成平衡二叉树。

平均查找长度是每个结点的查找次数之和/总结点数，每个结点查找次数就是根结点到指定结点的路径长+1（根节点算查找一次）。

## 平衡二叉树（Balanced Binary Tree / AVL）

`AVL`是发明人的名字`Adelson-Velsky-Landis Tree`，是二叉排序树的一种。

为了避免二叉排序树性能降低，规定在插入和删除结点时保证树上任一结点的左子树和右子树深度（高度）之差的绝对值不超过1，这个深度之差也称为平衡因子，因此平衡二叉树只可能有1、-1、0三种取值。

平衡二叉树的查找性能好，平均查找长度为`O(log2n)`。

### 最少所需结点

递推公式：

`n0=0`，`n1=1`，`n2=2`，`nh=1+nh-1+nh-2`

递归的思想，假设求第三个高度，那么如果有第二个高度最少结点，放左子树，第一个高度最少结点，放右子树，它们高度差也恰好是1，那么最少结点数就是这个递推公式。

`h`为平衡二叉树的高度，`nh`为构造此高度的平衡二叉树所需的最少结点数。

### 调整平衡二叉树

每次插入/删除后找到离插入结点最近的（从插入结点到根的路上）平衡因子的绝对值大于1的结点进行调整

规律：哪偏就是往哪旋，往哪旋就是哪孩子作根

#### LL平衡旋转

在一个结点的（当作根）左孩子（`L`）的左子树（`L`）上插入新结点，树偏左，左旋（左孩子作根，左孩子的右子树作为原根结点的左子树（即左孩子作根后右子树部分连接到原根结点了））。

#### RR平衡旋转

与`LL`同理，在结点右孩子的右子树上插入新结点，树偏右，右旋（右孩子作根）

#### LR、RL平衡旋转

`LR`即向结点的左孩子的右子树插入新结点。根结点左偏，且其根左子树右偏。

先把左孩子当作根，现在是右偏，因此要右旋（即该根的右孩子当根）。

然后再回到原视角现在是左偏，因此要左旋。

`RL`同理，先左旋再右旋。

## 哈夫曼树

树中结点数据域中带权值，从树根结点到任意结点的路径长度（边）与该结点上权值的乘积为该结点的带权路径长度。树所有结点的带权路径长度之和即为树的带权路径长度（`Weighted Path Length of Tree`，`WPL`）

### 构造

所有权值组成孤立集，取出最小的两个变为左孩子、右孩子，其父节点权值为它们二者之和，然后将该结点放回集合继续操作。

### 多叉哈夫曼树

假设是`m`叉哈夫曼树，即度为`m`的哈夫曼树，与常规哈夫曼树类似，它是需要取最小的`m`个元素组合成一个新的元素，然后以此类推。

但这样可能到后面还剩下的元素少于`m`个，一般解决办法是首先算出它组成了最后的哈夫曼树所需的结点然后补0：假设最后成功组成的哈夫曼树叶子结点有`n`个，则减去末尾的1个（刚开始需要`m`个元素组成，剩下的最少只需要`m-1`个，因为合成了新的）后应该有`(n-1)/(m-1)`余数为0。

## 二叉树的遍历

深度优先遍历、广度优先遍历是针对普通树而言。而二叉树中具体是有三种先序、中序、后序遍历的深度优先类算法。广度优先有层次遍历。

### 深度优先遍历

按照某条路径访问数中每个结点（规定`N`为根结点，`L`、`R`为左、右孩子），分为前序`NLR`、中序`LNR`、后序`LRN`遍历，`N`这个操作是读取结点数据，而`L`、`R`是遍历进去但不访问，是一种递归的操作。时间复杂度都是`O(n)`，空间复杂度最坏情况是`O(n)`（即存储了整个树）

递归算法很好写，如果转换为非递归需要使用栈。

后序遍历能找到一个结点的祖先结点到某结点的路径（后序遍历递归算法是访问到指定结点回退的时候记录路径，非递归是访问到该结点时记录栈中其祖先结点到它的路径）假设入口是祖先，出口是终点结点，那么后序遍历非递归遍历到终点的时候栈中会留有入口和出口（之所以不用先序遍历是因为它使用非递归算法的时候，入口已经出栈了，入口和出口不会同时存在）

#### 根据中序+先序/后序序列还原树

先序/后序 + 中序序列可以唯一的确定一棵树

从先序/后序中能获知根节点，然后从中序中找到根节点所在，划分为左子树序列和右子树序列，即可把树分为左子树和右子树。然后对左子树、右子树采取同样的操作。已知先序序列，求有多少种可能的中序序列，可以使用卡特兰数（即有多少种不同的树（因为先序序列和中序序列可以唯一的确定一棵树））（先序序列与中序序列的关系相当于以先序序列为入栈次序、以中序序列为出栈次序，是根据递归算法中递归的状态变化得出的）

- 注意能唯一还原树：通过中序可以确定结点是左孩子还是右孩子
- **先序、后序也可以用分治法划分。比如`ABCDE`，如果是先序，以第一个为根节点，可以划分为`AN(BC)L(DE)R` 然后分而治之：`BC`，把`B`看作`N`；`DE`，把`D`看作`N`… 后序同理，比如可以这样划分`(A)L(BCD)REN`**

层次序列+中序序列也可以唯一确定一颗树。

#### 线索二叉树

传统二叉链表实现的二叉树仅体现了父子关系，并不能直接得到结点在遍历序列中的前驱或者后继。线索二叉树是为了加快查找结点的前驱和后继的速度。

又因为二叉链表会有空指针的存在，因此可以利用空指针来存储前驱或者后继。规定左孩子如果为空就存储它的前驱（如果是序列的第一个结点则没有前驱是`null`），并将增设的`ltag=1`；类似的，规定右孩子如果为空就存储它的后继（如果是序列的最后一个结点则后继为`null`），并将增设的`rtag=1`。（算法实现是在一个结点如果发现自己的左孩子为空则指向前驱，如果自己的前驱结点的右孩子为空则指向自己）

线索二叉树是一种物理结构（存储结构），因为是二叉树这种逻辑结构限定了只能用链表实现，增设了线索指针，因此是物理结构（因为只有选择链式存储这种实现方式，因为逻辑结构可以有多种实现方式）

`n`个结点的线索二叉树含有的线索数是`n+1`。

考试要求画出先/中/后线索二叉树，使用二叉链表画法。如果是线索则使用虚线画箭头。技巧是画出树后，先写出先/中/后序的序列，然后根据序列中来找前驱和后继来画线索。

#### 线索二叉树的遍历

遍历中序线索二叉树的时候可以先直接找到线索的头，然后访问后继，根据（`LNR`），如果右孩子是线索，则直接能找到后继。但如果右孩子是结点，那么它的后继是右孩子的最左结点（因为中序遍历`LNR`，到了最`L`之后然后`N`就是访问了，那么即访问的最`L`结点）（但和普通的遍历算法时间复杂度都是`O(n)`）

遍历先序线索二叉树，找到线索头结点之后，根据（`NLR`），发现它后继先是`L`，那么就先判断如果它有左孩子，那么后继就是左孩子。如果没有`L`就考虑`R`，如果有右孩子或者是线索指向的则是其后继。

遍历后序线索二叉树，找到线索头结点`x`之后，
1. 根据（`LRN`），如果`x`是根节点`N1`，则没有后继。
2. 如果`x`是`N3`(`LRN2LRN3Nx`)（即是双亲的右孩子）或是`N2`（即是双亲的左孩子但没有右孩子），则后继为双亲。
3. 如果`x`是`N2`（即是双亲的左孩子，且双亲有右孩子）(`LRN2LRN3Nx`)则后继为双亲右子树上按后序遍历出的第一个结点

### 广度优先遍历

二叉树中称层次遍历。

借助队列来实现。针对队列中的一个结点，顺序是：
1. 出队，访问结点内容 
2. 如果有左孩子，将其入队。
3. 如果有右孩子，将其入队。

然后将根节点入队后，开始反复直到队列为空。

## 树、森林转二叉树

树转二叉树实际上就是将树使用孩子兄弟表示法存储，即左指针指向孩子，右指针（从左至右）指向兄弟。

森林是由多棵树组成，为了便于对森林的遍历等操作，需要将森林中的所有树都组合成一颗大的二叉树，转化步骤为：

1. 首先将森林中树各自转化为二叉树；

2. 森林中第一棵二叉树的树根作为转化后二叉树的树根；

3. 其他树的树根依次作为前一棵树根结点的右子树进行连接。（因为森林中的树各自转化为二叉树后树根结点都没有右孩子）

![树森林转二叉树](../attachments/73f77b2c101a8b314eaa57575c5e9326.png) 