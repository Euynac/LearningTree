# 尾递归
尾递归是指一个函数在调用自身之后不再执行任何其他操作，而是将返回值直接传递给函数调用的上级，从而避免了新的调用栈帧的创建。换句话说，尾递归是指递归调用发生在函数的最后一个语句中，从而使得函数调用不需要保存多个调用栈帧，而只需一个即可。
> 简单来说这个递归函数的return语句是它本身的递归函数。

比如：
```js
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

进行尾递归优化：
```js
function fibonacci(n, prev = 0, next = 1) {
  if (n === 0) {
    return prev;
  }
  return fibonacci(n - 1, next, prev + next);
}
```

第一种递归，因为无法直接结束函数调用，导致需要记录当前函数上下文的信息，包括传入参数、局部变量值等，并将这些信息保存在栈空间（也称调用栈或运行时栈）中。在递归过程中，每一次递归调用都会新建一个对应的栈帧（栈的一层）并保存上述信息。
  
而尾递归则是指递归过程中，只有一个栈帧被不断的更新。即，函数执行完成后直接返回结果，不再进行任何其他操作。这样一来，由于只占用一个栈帧，程序在空间上会得到很大优化，极大地降低了内存负担。同时，尾递归也可以被优化为迭代的形式，进一步减少时间负担。


# 浮点运算优化

## 快速幂算法

$$x ^ { 1024 } = x ^ { 512 } x ^ { 512 }$$