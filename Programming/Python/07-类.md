# 类（Class）

注意里面的self和cls都是建议的习惯命名，分别指的是实例，和类本身，并没规定死名字，但必须存在这样一个参数。

其中self可以看作是this，然后估计是设计人员偷懒，a.Foo()，这样好实现，就相当于a这个实例调用Foo方法，即Foo(a)

1.  \# We use the "class" statement to create a class
2.  class Human:
3.  
4.  \# A class attribute. It is shared by all instances of this class 这里叫做类的属性，但其实是单例，类似C\#中类的静态成员
5.  species = "H. sapiens"
6.  
7.  \# Basic initializer, this is called when this class is instantiated.类比构造函数, 注意python只有一个"构造函数"，可以通过下面的类方法做到多个构造函数
8.  def \__init__(self, name):
9.  \# Assign the argument to the instance's name attribute 在__init__中定义类的实例属性，每个类不同,这就类似C\#中的public属性。
10. self.name = name
11. \# Initialize property protect属性，可以通过定义getter、setter等方法进行外部修改
12. self._age = 0
13. 
14. \# An instance method. All methods take "self" as the first argument 实例方法，通过实例来调用，必须要有一个self参数传递实例本身，执行实例方法时自动传值self了。
15. def say(self, msg):
16. print("{name}: {message}".format(name=self.name, message=msg))
17. 
18. \# A class method is shared among all instances 类方法，唯一一个，与下面staticmethod静态方法很相似，都是通过类名来调用，不过不同的是类方法必须有一个参数cls传递类本身，执行实例方法时自动传值cls了。另外它可以被继承，然后重写。
19. @classmethod
20. def get_species(cls):
21. return cls.species
22. 
23. \# A static method is called without a class or instance reference 静态方法，也是唯一一个，但不需要传递参数，就很像一个全局工具方法。
24. @staticmethod
25. def grunt():
26. return "\*grunt\*"

## 继承（Inheritance）

python支持多重继承，这与许多语言不同，这会涉及到查找顺序（MRO）、重复调用（钻石继承）等问题。查找顺序是从左往右。

继承是在类定义的时候

class Iphone(Phone, Product):

这样就继承了两个类。

类方法的重写在python里面就是重新定义。

使用super()调用父类的方法 