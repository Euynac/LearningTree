# 函数

1.  \# Use "def" to create new functions 参数y是带有默认值的参数
2.  def add(x, y = 10):
3.  print("x is {} and y is {}".format(x, y))
4.  return x + y \# Return values with a return statement 若是return不带参数则返回None
5.  
6.  \# Calling functions with parameters 注意函数与下一条语句规范要有一个空行，代表函数结束。
7.  add(5, 6) \# =\> prints out "x is 5 and y is 6" and returns 11
8.  
9.  \# Another way to call functions is with keyword arguments 使用关键字参数调用函数
10. add(y=6, x=5) \# Keyword arguments can arrive in any order.
11. 
12. \# You can define functions that take a variable number of
13. \# positional arguments
14. def varargs(\*args):
15. return args
16. 
17. varargs(1, 2, 3) \# =\> (1, 2, 3) 即这种带\*的可变参数函数（也叫不定长参数）得到args的是个参数内容的元组。在函数参数上的\*意思是包装为元组
18. 
19. \# You can define functions that take a variable number of
20. \# keyword arguments, as well
21. def keyword_args(\*\*kwargs):
22. return kwargs
23. 
24. \# Let's call it to see what happens
25. keyword_args(big="foot", loch="ness") \# =\> {"big": "foot", "loch": "ness"} 即这种带\*\*的关键字可变参数函数得到的kwargs得到的是参数名和参数内容的dict。在函数参数上的\*\*意思是包装为字典
26. 
27. \# 混用两者也可以，\*包装的是正常参数，\*\* 包装的是关键字参数
28. \# 当在调用这种函数时，\*与\*\*这两个操作又做相反的事情，\*是展开元组，\*\*是展开字典
29. args = (1, 2, 3, 4)
30. kwargs = {"a": 3, "b": 4}
31. all_the_args(\*args) \# equivalent to call all_the_args(1, 2, 3, 4)
32. all_the_args(\*\*kwargs) \# equivalent to call all_the_args(a=3, b=4)
33. all_the_args(\*args, \*\*kwargs) \# equivalent to call all_the_args(1, 2, 3, 4, a=3, b=4)
34. 
35. 
36. \# Returning multiple values 能够返回多个结果，组成一个元组返回
37. def function():
38. return 1,2,3 \# Return multiple values as a tuple without the parenthesis. (Note: parenthesis have been excluded but can be included)
39. 
40. 
41. \# Python has first class functions （头等函数，也叫一等公民，是编程语言支持的编程特性。支持头等函数的编程语言支持将函数当作参数传递。个人理解即可以把函数当作对象传递，赋值后的变量就像是函数的别名，能够直接像调用函数一样调用，比如C++中的函数指针、C\#中的委托调用等（区别在于C++、C\#都事先分别声明了指针、委托支持的类型））
42. def create_adder(x):
43. def adder(y):
44. return x + y
45. return adder
46. 
47. add_10 = create_adder(10)
48. add_10(3) \# =\> 13

## 函数标注

比如可以用于第三方工具检查语法错误、使得阅读性更好等

有时候会使用def foo() -\> int: 其中-\> int是标记返回函数注释，信息作为.__annotations__属性提供,__annotations__属性是字典。可以使用foo.__anotations__获取

形参标注的定义方式是在形参名称后加上冒号(:)，后面跟参数类型，提示需要传入这个类型的参数。

## / and \* in formal parameter

![](../attachments/569c1d72b7f3520e39b5290cb027e48b.png)

/前面的形参必须要用位置参数

\*后面的形参必须要用关键词参数

## （arguments）\*args和（keyword arguements）\*\*kwargs

具体用法在上面的代码中有体现，这里做总结

**在函数定义中**

\*args表示不确定要往函数中传入多少个参数。

\*\*kwargs表示不确定要往函数中传入多少个关键词参数

当函数普通参数赋值完后，剩下的参数若多余就会全部在args中包装为元组。关键字参数类似，多余的关键字参数被包装为字典存入kwargs

**在函数调用过程中**

\*a表示将a变量元组或列表展开传入参数

\*\*b表示将b变量字典展开为关键字形式传入参数

## 匿名函数（anonymous function）

使用lambda关键字定义匿名函数

1.  (lambda x: x \> 2)(3) \# =\> True
2.  (lambda x, y: x \*\* 2 + y \*\* 2)(2, 1) \# =\> 5
3.  \# 类比C\#中的lambda表达式写匿名函数：
4.  delegate bool func(int num);
5.  func a = (x) =\> x \> 2;
6.  
7.  
8.  \# There are built-in higher order functions （内置）高阶函数，即使用函数做参数的函数，比如下面的map(函数, 列表)，对列表做一遍函数操作，filter（Func\<T,bool\>，List\<T\>）//用C\#意会
9.  list(map(add_10, [1, 2, 3])) \# =\> [11, 12, 13]
10. list(filter(lambda x: x \> 5, [3, 4, 5, 6, 7])) \# =\> [6, 7]

## \*内置函数（Built-in Functions）/魔法方法（dunder/magic methods）

内置函数都是作为全局函数来使用的，不需要导入即可直接使用，也就是说解释器启动是就加载了内置函数的上下文，有些方法的算法直接内置在解释器中，可以直接调用；有些会去调用方法的参数相对应的魔法方法，大部分魔法方法的实现算法也内置在了解释器中；

<https://www.cnblogs.com/cwp-bg/p/9829205.html>

https://blog.csdn.net/L_zzwwen/article/details/93362318

[官方全部的内置函数](https://docs.python.org/3/library/functions.html#__import__)

| 函数名           | 对象                         | 调用的魔法方法               | 介绍                                                                                                                                                                                                                                                                                                                                                                                                                           |
|------------------|------------------------------|------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| iter()           | 实现Iterable接口的可迭代对象 | \__iter__()                  | 可以获得一个 类型名_iterator的Iterator对象 for循环内部事实上就是先调用iter()把Iterable变成Iterator                                                                                                                                                                                                                                                                                                                             |
| next()           | Iterator对象                 | \__next__()                  | next()进行顺序访问取数，每次取数都会向下进行迭代，直到末尾，继续next()会产生StopIteration异常，若在中途进行list(迭代器对象)相当于一次性取完剩下的放到list中                                                                                                                                                                                                                                                                    |
| 类()             | 一个类的实例对象             | 存在调用__init__()           | 当一个类的实例被创建的时候调用的初始化方法，在创建对象时默认调用。 \__init__()方法默认有一个参数名字为self，若是定义（就像重写）这个方法存在传入参数的时候，需要显式指明self。比如 \__init__(self, x, y)来定义，然后使用self.xxx = x等语句来给类添加属性。 不需要返回值。self参数实际上是__new__返回的实例                                                                                                                     |
| 类()             | 一个类的实例对象             | 存在调用__new__()            | 也是类在创建实例时调用的方法，它比__init \__调用的时间还早。 该方法至少要有一个参数cls，代表要实例化的类，此参数在实例化时由python解释器自动提供。必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类即super().__new__(cls)出来的实例，或者直接是object的__new__出来的实例。在Python3中每个类都默认继承的object父类。 可以重写该方法通过定义私有属性存储对象判断是否为None来实现单例模式。 |
| str() 或 print() | 任何对象                     | \__str__()                   | str()类似于C\#中的ToString()方法，str()返回的是字符串类型，print()是返回None，但会打印出来。__str__()的默认实现是返回该对象的类型和内存地址的消息 可以重写类的方法格式化字符串                                                                                                                                                                                                                                                 |
| del()            | 任何对象                     | 当对象引用为0时调用__del__() | del()是主动删除对象的引用，就是把一个对象的名字给去掉，但若当python解释器检测到对象没有名字了，即这个对象的实际引用个数为0时（使用sys模块的getrefcount()方法可以得到一个对象的引用个数），就会删除这个对象，此时就会相应的调用__del__()方法。另外程序执行完毕释放内存也会调用此方法                                                                                                                                            |

## \*高阶函数

高阶函数指的是能接收函数作为参数的函数，比如map

<https://www.cnblogs.com/cwp-bg/p/8859260.html>

## \*\*装饰器（Decorators）@

装饰器其实就是面向切面编程AOP、洋葱/管道模型的思想的python实现。在不改变原有功能代码的基础上，添加额外的功能，将一个函数前后加上一个逻辑，每次调用这个函数会走一遍前后新加上的逻辑，就像给函数装饰了一遍。

使用场景：比如很多操作都需要登陆授权，给每个操作都写一遍登陆授权过于繁琐，把这前后的逻辑抽离出来，组成一个装饰器（洋葱模型里就是给套一层皮，每次调用这个函数会先走一遍皮然后进到内部，然后执行内部方法，最后从皮走出）

@开头的就是装饰器

1.  from functools import wraps
2.  
3.  def a_new_decorator(a_func):
4.  @wraps(a_func)
5.  def wraped_function(\*args, \*\*kwargs):
6.  print("I am doing some boring work before executing a_func()")
7.  a_func(\*args, \*\*kwargs)
8.  print("I am doing some boring work after executing a_func()")
9.  return wraped_function
10. 
11. @a_new_decorator
12. def a_function ():
13. print("I am the function")

@a_new_decorator这个装饰器装饰了a_function()

那么当调用a_function()的时候

实际上调用的是a_new_decorator(a_function)，最后被包装的成了wraped_function()，然后才进行函数调用。

另外wraped_function()中的\*args, \*\*kwargs参数是为了保持被修饰的函数调用参数不变。

@wrap这个在functools包中的装饰器的作用能够让被装饰的函数的__name__和__doc__不被改变（不加这个的话被装饰的函数已经不是之前那个原始函数了，所以写的注释都会被替换掉）

加了@wrap的实际上wraped_function 先被包装，调用的是wraps(wraped_function, a_function)，wrap这个装饰器里面做的动作就是将原来被修饰的函数一些内置属性都赋值到了即将装饰的函数上。最后被装饰为wraped_function返回。

## \*\*生成器（Generator）

在Python中，一边循环一边计算的机制，称为生成器。

**诞生背景**

列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。若仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。

简单一句话：我又想要得到庞大的数据，又想让它占用空间少，那就用生成器！

### 创建方式

①列表推导式使用()出来的即是生成式。

②如果一个函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）对象。

### 原理

生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。

yield相当于特殊的return，也是返回一个值，但不同的是它会记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行。

生成器.send(自定义结果)方法与next(生成器)类似，都会进行一次迭代，但不同的是这一次迭代的返回结果不是 yield 结果 而是send传入的自定义结果 