# 变量

注意`Python`其实并无引用类型和值类型的区分，`Python`中的变量类似于引用，所以变量无类型限制，这与强类型语言不同。`Python`的变量就像是对一个对象的引用，同一个对象能够有多个引用。`Python treats variables as mere labels (names) for values (objects)`。`Python`没有明确到底如何实现这种变量与对象的关系，它只描述了一系列变量能做到的功能。每个`Python`解释器比如`CPython`对于这种特性的实现不同，比如`CPython`是这样实现的：`Memory management in Python involves a private heap containing all Python objects and data structures`。所有对象都存在堆中。

变量不需要提前声明，也不存在类型声明。直接赋值然后使用。访问没有赋值过的变量会抛出`NameError`异常

## 可变对象（mutable）与不可变对象（immutable）

是否是可变对象关键在于对象本身能否被修改。不可变对象如`int`自身，比如`1`这个对象，它自身无法被修改，`a = 1`只是引用上了`1`这个对象，`Python`规定无法改变这个`1`对象本身的值，`a = 2`只是创建（可变对象若缓存中存在则直接引用不创建）新的`2`这个对象然后引用`2`。

![](../../attachments/189afde3f9ed41abac23f0acd7b361f6.png)

可变对象规定可以对原有变量本身进行修改，比如`list`

![](../../attachments/6fb4566f65208212b5284d86481ffd9c.png)

不可变对象可以作为字典`dict`的键`key`，而可变对象不行。

不可变对象类型有：`int`、`float`、`decimal`、`complex`、`bool`、`str`、`tuple`、`range`、`frozenset`、`bytes`

可变对象类型有：`list`、`dict`、`set`、`bytearray`、`user-defined classes` (unless specifically made immutable)

可变对象与不可变对象在函数参数传递中也是，前者不会改变自身，而后者会。

## 作用域（Scope）和命名空间（Namespace）

### 命名空间

提供了一种从名称到对象的映射，主要是通过字典来实现的。

`Python`中一共有三种命名空间：局部（`local namespace` 即函数中定义的名称）、全局（`global namespace` 模块中定义的名称，包括类、常量、函数等等）、内置（`build-in namespace`内置函数等）

可以使用`locals()`（获取当前作用域的命名空间，如果在全局作用域中调用则获取全局命名空间，如果在函数作用域中调用则获取函数命名空间），`globals()`函数来获取当前命名空间的值（返回的是字典）

### 作用域

可以理解为变量所起作用的范围，超出范围则某变量不能被使用

定义在函数外部的变量是全局域的（`global`），属于全局变量，将这个模块导入，其他在其他模块也能访问到。

函数内部的变量则是局部变量，局部变量外面无法访问到。如果想要在内部访问全局变量，可以直接访问，但是注意访问之后不能使用赋值语句，赋值语句会让它在整个局部块（因此先访问全局变量再赋值是会出错的），新建了一个新的名字和全局变量一样的局部变量，因此会导致前面访问的变量`local variable referenced before assignment` 错误（因为导致前面那个被访问的认为是访问的后面这个新键的局部变量）。另外如果全局变量是可变对象，使用全局变量的方法是可以修改全局变量的。

如果直接先赋值，新建一个和全局变量名字一样的局部变量是可以的，一旦赋值，这变量就和全局变量没有关系了。

如果要在局部域中进行赋值修改等操作，可以使用`global`关键字显式声明变量为在内部使用的全局变量，这时候就没有上面那么多幺蛾子了。

变量作用域查找规则：`Local`--->`Enclosing`--->`Global`--->`Build-in`（内置变量）

`Enclosing`这个是嵌套函数中出现的，因为相对于最内层函数而言，上层函数即不是全局变量也不是局部变量。`nonlocal`关键字就能去修改这个`Enclosing`变量，`global`关键字是去修改`Global`变量的。

## *内置变量/魔法属性

| 变量名         | 应用     | 作用                                                                                                                                                                                                                                                                                                                                   |
|----------------|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `__name__`     |          | `Python`模块的入口文件的`__name__`变量会置为`'__main__'`，若是被其他`py`文件当作模块导入，`__name__`为模块名（即`py`文件名）                                                                                                                                                                                                                       |
| `__slots__`    | 定义类时 | `Python`是一门动态语言，可以在程序运行的过程中添加属性。如果我们想要限制实例的属性该怎么办？例如，只允许对`Person`实例添加`name`和`age`属性。`Python`允许在定义`class`的时候，定义一个特殊的 `__slots__`变量，来限制该`class`实例能添加的属性 `__slots__ = ("name", "age")` 注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。 |
| `__all__`      | 模块内部 | 当`import`模块时，若要使用模块中的私有属性，如果模块中存在`__all__`这个变量，那么就按这个变量里的内容进行导入，没有包含的不导入。                                                                                                                                                                                                          |
| `__builtins__` |          | 存的是内建模块对象，不需要手动`import`，直接使用里面的函数。 `dir(__builtins__)`查看有哪些内置函数、变量、类等                                                                                                                                                                                                                             |

## *使用环境变量

做`Python`项目时时常会去使用环境变量，从环境变量中导入变量或获取值能让一些包获得很好的兼容性，做一些配置操作非常方便。

环境变量是对系统而言的，这些操作在`os.environ`模块中

```python
os.environ['HTTPS_PROXY'] = "http:127.0.0.1:8888"
```

比如这样就设置了一个名为`HTTPS_PROXY`的环境变量。实际上原理是`environ`类里面有字典，运行之后会先自动加载系统的环境变量，这里设置的`HTTPS_PROXY`就类似于操作字典，存在的替换，不存在则添加。因此这个环境变量是临时的，并没有改变系统环境变量，可以做一些针对程序临时的运行配置 