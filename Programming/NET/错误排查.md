# 错误排查

## Linq

### DistinctBy
似乎需要`ToList()`才有效，无法使用`IEnumerable`，否则会报错
```csharp
 foreach (var assembly in modelBuilder.Model.GetEntityTypes().Select(p => Assembly.GetAssembly(p.ClrType))
              .DistinctBy(a => a!.FullName)) //不ToList将报错
 {
     modelBuilder.ApplyConfigurationsFromAssembly(assembly!);
 }
```

## 编译
Release模式下编译，`Linux Docker`环境运行起来中文乱码

原理是因为`VS2022`生成的`Dockerfile`编译是拷贝了源代码到容器内编译，而如果本机的代码文件编码为`GB2312`，当时拷过去的时候文件已经乱码，因此编译为二进制文件还是乱码，执行的时候自然也是乱码。

另外还有`CRCF`的问题，如果是`sh`脚本，在`linux`下就运行不正常。



## 加载外部程序集

日前遇到一个加载外部dll程序集 `AsterixDecoder.dll` 然后在反射获取相关类型时：

 ```
Could not load file or assembly 'AsterixDecoder, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null'. The system cannot find the file specified.
  - Phase: PostConfigureServices
  - Stack Trace:    at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
   at Microsoft.AspNetCore.Mvc.Controllers.ControllerFeatureProvider.PopulateFeature(IEnumerable`1 parts, ControllerFeature feature)
   at Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature)
   at Microsoft.Extensions.DependencyInjection.MvcCoreMvcBuilderExtensions.AddControllersAsServices(IMvcBuilder builder)
   at MoLibrary.Core.Modules.ModuleControllers.PostConfigureServices(IServiceCollection services) in D:\Code\MoLibrary\MoLibrary.Core\Modules\Controllers.cs:line 27
   at MoLibrary.Core.Module.MoModule`3.<ConvertToRegisterRequest>b__8_2(ModuleRegisterContextWrapperForServices`1 context) in D:\Code\MoLibrary\MoLibrary.Core\Module\MoModule.cs:line 82
   at MoLibrary.Core.Module.Interfaces.MoModuleGuide`3.<>c__DisplayClass13_0.<PostConfigureServices>b__0(ModuleRegisterContext registerContext) in D:\Code\MoLibrary\MoLibrary.Core\Module\Interfaces\MoModuleGuide.cs:line 278
   at MoLibrary.Core.Module.MoModuleRegisterCentre.RegisterServices(WebApplicationBuilder builder) in D:\Code\MoLibrary\MoLibrary.Core\Module\MoModuleRegisterCentre.cs:line 239
   at MoLibrary.Core.Module.Exceptions.ModuleErrorUtil.RaiseModuleErrors() in D:\Code\MoLibrary\MoLibrary.Core\Module\Exceptions\ModuleErrorUtil.cs:line 257
   at MoLibrary.Core.Module.MoModuleRegisterCentre.RegisterServices(WebApplicationBuilder builder) in D:\Code\MoLibrary\MoLibrary.Core\Module\MoModuleRegisterCentre.cs:line 251
   at MoLibrary.Core.Module.BuilderWrapper.WebApplicationBuilderExtensions.MoBuild(WebApplicationBuilder builder) in D:\Code\MoLibrary\MoLibrary.Core\Module\BuilderWrapper\WebApplicationBuilderExtensions.cs:line 57
   at Program.<Main>$(String[] args) in D:\Code\ROMP\src\ROMP.Api\Program.cs:line 171
 ```

实际上又存在这个dll在程序集旁边，且直接手动LoadAssembly可以获取到反射类型。

解决方案：
```
The AsterixDecoder is in ROMP.Core.deps.json but NOT in ROMP.Api.deps.json. When the API runs, it uses its own deps.json for assembly resolution, so it can't
  find AsterixDecoder even though the physical file is there.
The issue is that direct DLL references (non-NuGet) don't automatically propagate to dependent projects. Let's fix this by making the reference properly transitive

```

将 `.csproj` 的引用改为：
```xml
<ItemGroup>  
  <Reference Include="AsterixDecoder">  
    <HintPath>packages\cat011parser.ZCW.2023.10.10\cat011_zhhh_zgha\Release\netstandard2.0\AsterixDecoder.dll</HintPath>  
    <Private>True</Private>  
  </Reference> 
   <!-- Ensure AsterixDecoder is copied to dependent projects -->  
  <None Include="packages\cat011parser.ZCW.2023.10.10\cat011_zhhh_zgha\Release\netstandard2.0\AsterixDecoder.dll">  
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>  
    <Link>AsterixDecoder.dll</Link>  
    <Visible>false</Visible>  
</None></ItemGroup>
```

