# 异常处理


## 异常抛出流程

- `throw;`：保留原始堆栈跟踪。
- `throw ex;`：重置堆栈跟踪（会丢失原始异常位置）。

若未对异常进行处理：

### catch块异常

```cs
try
{
    throw new InvalidOperationException("原始异常");
}
catch (Exception ex)  // 捕获原始异常
{
    // 这里可以访问原始异常: ex
    throw new FileNotFoundException("新异常"); // ⚠️ 此处抛出新异常，原始ex被隐藏
}
```
- 外层调用者只会看到`FileNotFoundException`（新异常）。
- 原始异常（`InvalidOperationException`）会被新异常覆盖，不再向上传递。

### finally块异常

会覆盖之前所有异常。


```cs
try
{
    throw new InvalidOperationException("原始异常");
}
catch (Exception ex)
{
    // 在 catch 块中抛出新异常
    throw new ApplicationException("catch 块中的新异常", ex);
}
finally
{
    throw new FileNotFoundException("finally 异常");
}
```

结果：

- 最终传播的异常是 finally 块中的 FileNotFoundException
- catch 块中抛出的 ApplicationException（包含原始异常作为 InnerException）​**​完全丢失​**

### using中Dispose出现异常

因为using原理如同下面的转换：

```csharp
using (SqlConnection conn = new SqlConnection("connectionstring"))
{
    //some work
}
```

Would get translated into

```csharp
{
    SqlConnection conn = new SqlConnection("connectionstring");
    try
    {
        //somework
    }
    finally
    {
        ((IDisposable)conn).Dispose();
    }
}
```

因此异常流程同 finally 块的异常处理。

**所以Dispose方法、finally块、catch块最好是保证不会出现异常**


## 未捕获的异常

某些线程上引发的异常不会被捕获，需要用以下方式：

```csharp
var curDomain = AppDomain.CurrentDomain;
curDomain.UnhandledException += new UnhandledExceptionEventHandler((sender, eventArgs) =>
{
    var ex = (Exception) eventArgs.ExceptionObject;
    KouLog.QuickAdd($"程序异常捕获：{ex.ToJsonString()}");
});

TaskScheduler.UnobservedTaskException += (sender, e) =>
{
    KouLog.QuickAdd($"任务异常捕获：{e.ToJsonString()}");
};
```

而对于Winform等线程上引发的异常，还需要使用`Application.ThreadException`去捕获。


## 注意事项

#### Json序列化问题
注意，`System.Text.Json` 无法 Serialize `Exception`，参见<https://github.com/dotnet/runtime/issues/43026>


### 日志记录
注意使用`ILogger`进行日志记录的时候，不可以直接用 `logger.Log($"{e}")`，无法记录`innerException`。通过其内部写异常的方法可以同时输出内部异常及相应堆栈：`logger.Log(e, "msg")`