# C语言指针

## `&`运算符与`*`运算符

`*`在声明变量时是表示变量是指向声明的类型的指针

```c
int a, *p, *q;
```

其中`p`、`q`为指针变量，意思是能够指向`int`这种数据类型的变量，存的内容是`int`数据类型变量的地址。

### `&` 变量 （取地址运算）

`&`是取地址符（单目运算符），返回其后变量（包括数组元素）的地址，返回类型是"地址类型"，实际上就是对应的指针类型。`register`存储类型的变量不能使用`&`返回地址

即需要这样使用：

```c
p = &a;
p = q; //相同类型之间的指针也可以互相赋值
```

### `*` 指针变量（或表达式）（取内容运算）

取内容运算符是单目运算符，返回其后地址对应存储单元的内容，又称为"间接访问运算符"。

```c
p = &a;
*p = 10;//间接访问变量a，其实*p的运算结果就相当于了一个a。而后赋值10，事实上就是a = 10;
```

## 指针表达式

指针表达式可以加或减一个整型数据

```c
p + n;//p的地址+p指向类型的字节数*n（p当前存储单元后面第n个存储单元的地址）
p - n;// p的地址-p指向类型的字节数*n（p当前存储单元前面第n个存储单元的地址）
```

可以使用自增、自减。

### 相同类型指针的加减法运算

```c
p - q;//结果是两个地址（指针）之间间隔的数据个数（而不是实际上的地址字节十进制差值）
```

## 强制转换为指针类型

```c
int *px, x = 10;
float *pf;
px = &x;
pf = (float *)px;//能否强转得看它们所存地址长度大小来看
```

## 空指针

指针变量定义后，不对其赋值（包括不初始化），指针变量存储的地址是不确定的，直接对其访问修改会导致不可预料的错误。因此使用前需要置空或赋值。

C语言在头文件`stdio.h`中定义了 `#define NULL 0`

因此可以

```c
int *p = 0;
int *p = NULL;
```

## 多级指针（指向指针的指针）

```c
int **p, *q, d;
q = &d;
p = &q;
```

`**p`是`int`型二级指针：指向`int`型一级指针`*q`，存储的内容是一级指针所在的地址。

## 常量指针与指针常量

```c
const int *p;//常量指针，指向常量的指针
```

这个指的是`p`是指向`const int`这种常量`int`类型的变量的指针。因此指针指向的内容不能修改（因为是常量），而指针内容（地址）可以修改，指向不同的常量`int`。

```c
int *const p;//指针常量，该指针是一个常量。
```

是指的这个指针指向后无法修改（定义时必须赋初值），即不能指向另外的地方。但指针指向的内容可以被修改。

```c
const int *const p;//常量指针常量，额，就是上面两者的合体。
```

## 个人理解

个人认为可以这样思考"地址类型"，`int *p` 其实就是`int *`类型，`int`类型变量使用`&`运算符就变为`int *`类型，再使用一次就是`int **`类型。使用`*`取内容运算`int *`类型就变为`int`类型。带`*`的类型内容都是地址，且只有此种类型可以使用`*`取内容运算。

数组类型，其数组名是数组首地址。数组名也可以看作是指定类型的一种常量指针（即无法修改）比如一维数组：

```c
int a[5] = {2,4,5,6,7};
```

`a`实际上可以看作是特殊的`const int *a;`

```c
a[1] = 5;//这个操作实际上是 *(a+1) = 5;
```

## 结构体指针

使用结构体指针变量访问结构体时，可以使用成员运算符`.`或指向运算符`->`

```c
(*struct).data //"."的优先级比*高
pstruct->data // ->优先级最高
```

## 函数中的指针

数组名在当参数传递时,会完全退化为指针，因此使用`sizeof(arrayName)/sizeof(arrayName[0])`求数组长度时不能直接这样。
