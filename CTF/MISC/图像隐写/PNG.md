# 结构

PNG文件头为 `89 50 4E 47 0D 0A 1A 0A`

PNG图像格式文件由一个8字节的PNG文件标识（file signature or file header）域和3个以上的后续数据块(chunk)如:IHDR、IDAT、IEND等组成。

| 十六进制 | 含义                                                                                                           |
| -------- | -------------------------------------------------------------------------------------------------------------- |
| 89       | 用于检测传输系统是否支持8位的字符编码（8 bit data），用以减少将文本文件被错误的识别成PNG文件的机会，反之亦然。 |
| 50 4E 47 | PNG每个字母对应的ASCII，让用户可以使用文本编辑器查看时，识别出是PNG文件。                                      |
| 0D 0A    | DOS风格的换行符（CRLF）。用于DOS-Unix数据的换行符转换。                                                        |
| 1A       | 在DOS命令行下，用于阻止文件显示的文件结束符。                                                                  |
| 0A       |Unix风格的换行符（LF）。用于Unix-DOS换行符的转换。|



# 数据块（Chunk）

PNG定义了两种类型的数据块，有四种必选的称为关键数据块(critical chunk)，另一些可选的叫做辅助数据块(ancillary chunks)，这是可选的数据块。虽然PNG文件规范没有要求PNG编译码器对可选数据块进行编码和译码，但规范提倡支持可选数据块。

|数据块符号|数据块名称|多数据块|可选否|位置限制|
|---|---|---|---|---|
|**IHDR**|文件头数据块|否|否|第一块|
|cHRM|基色和白色点数据块|否|是|在PLTE和IDAT之前|
|gAMA|图像γ数据块|否|是|在PLTE和IDAT之前|
|sBIT|样本有效位数据块|否|是|在PLTE和IDAT之前|
|**PLTE**|调色板数据块|否|是|在IDAT之前|
|bKGD|背景颜色数据块|否|是|在PLTE之后IDAT之前|
|hIST|图像直方图数据块|否|是|在PLTE之后IDAT之前|
|tRNS|图像透明数据块|否|是|在PLTE之后IDAT之前|
|oFFs|(专用公共数据块)|否|是|在IDAT之前|
|pHYs|物理像素尺寸数据块|否|是|在IDAT之前|
|sCAL|(专用公共数据块)|否|是|在IDAT之前|
|**IDAT**|图像数据块|是|否|与其他IDAT连续|
|tIME|图像最后修改时间数据块|否|是|无限制|
|tEXt|文本信息数据块|是|是|无限制|
|zTXt|压缩文本数据块|是|是|无限制|
|fRAc|(专用公共数据块)|是|是|无限制|
|gIFg|(专用公共数据块)|是|是|无限制|
|gIFt|(专用公共数据块)|是|是|无限制|
|gIFx|(专用公共数据块)|是|是|无限制|
|**IEND**|图像结束数据|否|否|最后一个数据块|


## 数据块结构


|名称|字节数|说明|
|---|---|---|
|长度(Length)|4字节|指定数据块中数据区域的长度，长度不可超过(231-1)个字节|
|数据块类型码(Chunk Type Code)|4字节|数据块类型码由ASCII字母(A-Z和a-z)组成的"数据块符号"|
|数据块数据(Chunk Data)|可变长度|存储数据块类型码指定的数据|
|循环冗余检测(CRC)|4字节|存储用来检测是否文件传输有误的循环冗余码|

## 标准数据块

### 文件头数据块IHDR（header chunk）

它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。

| 域的名称           | 字节数  | 说明                                                                                                                                                                                   |
| ------------------ | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Width              | 4 bytes | 图像宽度，以像素为单位                                                                                                                                                                 |
| Height             | 4 bytes | 图像高度，以像素为单位。                                                                                                                                                               | 
| Bit depth          | 1 byte  | 图像深度：   <br>索引彩色图像：1，2，4或8   <br>灰度图像：1，2，4，8或16   <br>真彩色图像：8或16                                                                                       |
| ColorType          | 1 byte  | 颜色类型：  <br>0：灰度图像, 1，2，4，8或16   <br>2：真彩色图像，8或16   <br>3：索引彩色图像，1，2，4或8   <br>4：带α通道数据的灰度图像，8或16   <br>6：带α通道数据的真彩色图像，8或16 |
| Compression method | 1 byte  | 压缩方法(LZ77派生算法)                                                                                                                                                                 |
| Filter method      | 1 byte  | 滤波器方法                                                                                                                                                                             |
| Interlace method   | 1 byte  | 隔行扫描方法：  <br>0：非隔行扫描   <br>1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)                                                                                             |

#### ※宽高隐写
IHDR会出现宽高隐写。
一般是高隐写，在windows中直接往大的值修改高即可。在linux中如CRC不匹配则报错无法显示。
直接修改宽会导致图片显示异常，需要修改使得CRC匹配。
图片显示异常的不只是那种彩色点等异常的，还包括看似正常的图片：
![](../../../attachments/Pasted%20image%2020230807234958.png)

只需要有CRC，就能爆破出宽高，CRC爆破脚本：

```python
import struct
import binascii
import os
import sys
png = sys.argv[1]
print(png)
m = open(png,"rb").read()
# print(m[20:29])
for i in range(5000):
    for j in range(5000):
        c = m[12:16] + struct.pack('>i', i) + struct.pack('>i', j)+m[24:29]
        crc = binascii.crc32(c) & 0xffffffff
        if crc == 0xF30971FC:
            #print(c)
            print(hex(i),hex(j))
            break
```


### 调色板数据块PLTE（palette chunk）

调色板数据块PLTE(palette chunk)包含有与索引彩色图像(indexed-color image)相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块(image data chunk)之前。

PLTE数据块是定义图像的调色板信息，PLTE可以包含1~256个调色板信息，每一个调色板信息由3个字节组成：

|颜色|字节|意义|
|---|---|---|
|Red|1 byte|0 = 黑色, 255 = 红|
|Green|1 byte|0 = 黑色, 255 = 绿色|
|Blue|1 byte|0 = 黑色, 255 = 蓝色|

因此，调色板的长度应该是3的倍数，否则，这将是一个非法的调色板。

对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4=16），否则，这将导致PNG图像不合法。

真彩色图像和带alpha通道数据的真彩色图像也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。

### 图像数据块IDAT（image data chunk）

存储实际图像数据。PNG数据允许包含多个连续的图像数据块。
IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像

#### ※IDAT隐写

> 标志：当上一个IDAT块未填充满时出现了下一个IDAT块。

最好有三个以上的IDAT才好判断。
通过010的模板分析，如果第一个IDAT块大小为1000，第二个IDAT为800，第三个IDAT为600，这里就可以判断出来第三个块是隐写的数据，因为只有当第二个IDAT填充到1000后，才会继续填充第三个IDAT
![](../../../attachments/Pasted%20image%2020230801220336.png)
可以用脚本读取来解题：
```python
import zlib
import binascii
fp = open('pngpng.png','rb')
fp.seek(96775,0) # 这其实就是数据块的起始
fp1 = zlib.decompress(binascii.unhexlify(fp.read(98).hex()))
fp2 = open('1.rar','wb')
fp2.write(fp1)
```

因为PNG是采用了无损的zlib算法压缩图像数据，所以提取数据还得用zlib算法解压。

### 图像结束数据IEND（image trailer chunk）

放在文件尾部，表示PNG数据流结束。

#### ※附加隐写

> 标志：IEND后不应该再有数据块